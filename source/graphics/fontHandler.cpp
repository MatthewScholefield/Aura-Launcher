#include <gl2d.h>
#include <list>
#include <stdio.h>
#include "Font.h"
#include "fontHandler.h"
#include "TextEntry.h"

// GRIT auto-genrated arrays of images
#include "font_si.h"
#include "font_16x16.h"

// Texture UV coords
#include "uvcoord_font_si.h"
#include "uvcoord_font_16x16.h"
#include "TextPane.h"

using namespace std;

Font smallFont;
Font largeFont;

glImage smallFontImages[FONT_SI_NUM_IMAGES];
glImage largeFontImages[FONT_16X16_NUM_IMAGES];

list<TextEntry> topText, bottomText;
list<TextPane> panes;

void fontInit()
{
	// Set  Bank A to texture (128 kb)
	vramSetBankA(VRAM_A_TEXTURE);
	smallFont.load(smallFontImages, // pointer to glImage array
				FONT_SI_NUM_IMAGES, // Texture packer auto-generated #define
				font_si_texcoords, // Texture packer auto-generated array
				GL_RGB256, // texture type for glTexImage2D() in videoGL.h
				TEXTURE_SIZE_64, // sizeX for glTexImage2D() in videoGL.h
				TEXTURE_SIZE_128, // sizeY for glTexImage2D() in videoGL.h
				GL_TEXTURE_WRAP_S | GL_TEXTURE_WRAP_T | TEXGEN_OFF | GL_TEXTURE_COLOR0_TRANSPARENT, // param for glTexImage2D() in videoGL.h
				256, // Length of the palette (256 colors)
				(u16*) font_siPal, // Palette Data
				(u8*) font_siBitmap // image data generated by GRIT
				);

	// Do the same with our bigger texture
	largeFont.load(largeFontImages,
				FONT_16X16_NUM_IMAGES,
				font_16x16_texcoords,
				GL_RGB256,
				TEXTURE_SIZE_64,
				TEXTURE_SIZE_512,
				GL_TEXTURE_WRAP_S | GL_TEXTURE_WRAP_T | TEXGEN_OFF | GL_TEXTURE_COLOR0_TRANSPARENT,
				256,
				(u16*) font_siPal,
				(u8*) font_16x16Bitmap
				);
}

TextPane &createTextPane(int startX, int startY, int shownElements)
{
	panes.emplace_back(startX, startY, shownElements);
	return panes.back();
}

static list<TextEntry> &getTextQueue(bool top)
{
	return top ? topText : bottomText;
}

Font &getFont(bool large)
{
	return large ? largeFont : smallFont;
}

void updateText(bool top)
{
	auto &text = getTextQueue(top);
	for (auto it = text.begin(); it != text.end(); ++it)
	{
		if (it->update())
		{
			it = text.erase(it);
			--it;
			continue;
		}
		glPolyFmt(POLY_ALPHA(it->calcAlpha()) | POLY_CULL_NONE | POLY_ID(1));
		getFont(it->large).print(it->x / TextEntry::PRECISION, it->y / TextEntry::PRECISION, it->message);
	}
	for (auto it = panes.begin(); it != panes.end(); ++it)
	{
		if (it->update(top))
		{
			it = panes.erase(it);
			--it;
			continue;
		}
	}
}

void clearText(bool top)
{
	list<TextEntry> &text = getTextQueue(top);
	for (auto it = text.begin(); it != text.end(); ++it)
	{
		if (it->immune)
			continue;
		it = text.erase(it);
		--it;
	}
}

void clearText()
{
	clearText(true);
	clearText(false);
}

void printSmall(bool top, int x, int y, const char *message)
{
	getTextQueue(top).emplace_back(false, x, y, message);
}

void printLarge(bool top, int x, int y, const char *message)
{
	getTextQueue(top).emplace_back(true, x, y, message);
}

TextEntry *getPreviousTextEntry(bool top)
{
	return &getTextQueue(top).back();
}

void animateTextIn(bool top)
{
	const int SLIDE_X = 16;
	int numElements = 0;
	list<TextEntry> &text = getTextQueue(top);
	for (auto it = text.begin(); it != text.end(); ++it)
	{
		if (it->immune)
			continue;
		it->delay = numElements++ * 2;
		it->x = TextEntry::PRECISION * (it->initX = it->finalX - SLIDE_X);
		it->fade = TextEntry::FadeType::IN;
	}
}

void scrollTextVert(bool top, bool up, TextEntry &newEntry)
{
	list<TextEntry> &text = getTextQueue(top);
	int first = -1, last = 0, counter = -1;
	for (auto it = text.begin(); it != text.end(); ++it)
	{
		if (first < 0)
			--first;
		++counter;
		if (it->immune || it->fade == TextEntry::FadeType::OUT)
			continue;

		if (first < 0)
			first = -1 * first - 2;
		last = counter;
		it->delay = TextEntry::ACTIVE;
		it->finalY += FONT_SY * (up ? -1 : 1);
		it->fade = TextEntry::FadeType::NONE;
	}

	newEntry.delay = TextEntry::ACTIVE;
	newEntry.finalY += FONT_SY * (up ? -1 : 1);
	newEntry.fade = TextEntry::FadeType::IN;

	auto it = next(text.begin(), up ? first : last);
	it->fade = TextEntry::FadeType::OUT;
	it->initX = it->x / TextEntry::PRECISION;
	it->initY = it->y / TextEntry::PRECISION;
	if (up)
		text.push_back(newEntry);
	else
		text.push_front(newEntry);
}