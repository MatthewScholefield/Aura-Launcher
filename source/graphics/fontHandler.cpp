#include <gl2d.h>
#include <list>
#include <stdio.h>
#include "Font.h"
#include "fontHandler.h"

// GRIT auto-genrated arrays of images
#include "font_si.h"
#include "font_16x16.h"

// Texture UV coords
#include "uvcoord_font_si.h"
#include "uvcoord_font_16x16.h"

using namespace std;

Font smallFont;
Font largeFont;

glImage smallFontImages[FONT_SI_NUM_IMAGES];
glImage largeFontImages[FONT_16X16_NUM_IMAGES];

list<TextEntry> topText, bottomText;

void fontInit()
{
	// Set  Bank A to texture (128 kb)
	vramSetBankA(VRAM_A_TEXTURE);
	smallFont.load(smallFontImages, // pointer to glImage array
				FONT_SI_NUM_IMAGES, // Texture packer auto-generated #define
				font_si_texcoords, // Texture packer auto-generated array
				GL_RGB256, // texture type for glTexImage2D() in videoGL.h
				TEXTURE_SIZE_64, // sizeX for glTexImage2D() in videoGL.h
				TEXTURE_SIZE_128, // sizeY for glTexImage2D() in videoGL.h
				GL_TEXTURE_WRAP_S | GL_TEXTURE_WRAP_T | TEXGEN_OFF | GL_TEXTURE_COLOR0_TRANSPARENT, // param for glTexImage2D() in videoGL.h
				256, // Length of the palette (256 colors)
				(u16*) font_siPal, // Palette Data
				(u8*) font_siBitmap // image data generated by GRIT
				);

	// Do the same with our bigger texture
	largeFont.load(largeFontImages,
				FONT_16X16_NUM_IMAGES,
				font_16x16_texcoords,
				GL_RGB256,
				TEXTURE_SIZE_64,
				TEXTURE_SIZE_512,
				GL_TEXTURE_WRAP_S | GL_TEXTURE_WRAP_T | TEXGEN_OFF | GL_TEXTURE_COLOR0_TRANSPARENT,
				256,
				(u16*) font_siPal,
				(u8*) font_16x16Bitmap
				);
}

static list<TextEntry> &getTextQueue(bool top)
{
	return top ? topText : bottomText;
}

static Font &getFont(bool large)
{
	return large ? largeFont : smallFont;
}

static int calcAlpha(const TextEntry &i)
{
	/*if (i.fade == TextEntry::FadeType::OUT)
		return 0;*/
	int routeLength = abs(i.initX - i.finalX) + abs(i.initY - i.finalY);
	if (i.fade == TextEntry::FadeType::NONE || routeLength == 0)
		return 31;

	routeLength *= TextEntry::PRECISION;
	int curDist = abs(i.x - i.finalX * TextEntry::PRECISION) + abs(i.y - i.finalY * TextEntry::PRECISION);
	int alpha = (i.fade == TextEntry::FadeType::IN ? 31 : 0) - (31 * curDist) / routeLength;
	alpha *= i.fade == TextEntry::FadeType::OUT ? -1 : 1;
	return max(alpha, 0);
}

void updateText(bool top)
{
	auto &text = getTextQueue(top);
	for (auto it = text.begin(); it != text.end(); ++it)
	{
		if (it->delay > 0)
		{
			glPolyFmt(POLY_ALPHA(0) | POLY_CULL_NONE | POLY_ID(1));
			--it->delay;
		}
		else if (it->delay == TextEntry::ACTIVE)
		{
			it->x += (it->finalX * TextEntry::PRECISION - it->x) / it->invAccel;
			it->y += (it->finalY * TextEntry::PRECISION - it->y) / it->invAccel;
			int alpha = calcAlpha(*it);
			if (alpha <= 2 && it->fade == TextEntry::FadeType::OUT)
			{
				it = text.erase(it);
				--it;
				continue;
			}
			glPolyFmt(POLY_ALPHA(alpha) | POLY_CULL_NONE | POLY_ID(1));
			if (it->x / TextEntry::PRECISION == it->finalX)
				it->delay = TextEntry::ACTIVE; //COMPLETE;
		}
		else
			glPolyFmt(POLY_ALPHA(31) | POLY_CULL_NONE | POLY_ID(1));
		getFont(it->large).print(it->x / TextEntry::PRECISION, it->y / TextEntry::PRECISION, it->message);
	}
}

void clearText(bool top)
{
	list<TextEntry> &text = getTextQueue(top);
	for (auto it = text.begin(); it != text.end(); ++it)
	{
		if (it->immune)
			continue;
		it = text.erase(it);
		--it;
	}
}

void clearText()
{
	clearText(true);
	clearText(false);
}

void printSmall(bool top, int x, int y, const char *message)
{
	getTextQueue(top).emplace_back(false, x, y, message);
}

void printLarge(bool top, int x, int y, const char *message)
{
	getTextQueue(top).emplace_back(true, x, y, message);
}

TextEntry *getPreviousTextEntry(bool top)
{
	return &getTextQueue(top).back();
}

void animateTextIn(bool top)
{
	const int SLIDE_X = 16;
	int numElements = 0;
	list<TextEntry> &text = getTextQueue(top);
	for (auto it = text.begin(); it != text.end(); ++it)
	{
		if (it->immune)
			continue;
		it->delay = numElements++ * 2;
		it->x = TextEntry::PRECISION * (it->initX = it->finalX - SLIDE_X);
		it->fade = TextEntry::FadeType::IN;
	}
}

void animateTextVert(bool top, bool up, TextEntry &newEntry)
{
	list<TextEntry> &text = getTextQueue(top);
	int first = -1, last = 0, counter = -1;
	for (auto it = text.begin(); it != text.end(); ++it)
	{
		if (first < 0)
			--first;
		++counter;
		if (it->immune || it->fade == TextEntry::FadeType::OUT)
			continue;
		
		if (first < 0)
			first = -1 * first - 2;
		last = counter;
		it->delay = TextEntry::ACTIVE;
		it->finalY += FONT_SY * (up ? -1 : 1);
		it->fade = TextEntry::FadeType::NONE;
	}

	newEntry.delay = TextEntry::ACTIVE;
	newEntry.finalY += FONT_SY * (up ? -1 : 1);
	newEntry.fade = TextEntry::FadeType::IN;

	auto it = next(text.begin(), up ? first : last);
	it->fade = TextEntry::FadeType::OUT;
	it->initX = it->x / TextEntry::PRECISION;
	it->initY = it->y / TextEntry::PRECISION;
	if (up)
		text.push_back(newEntry);
	else
		text.push_front(newEntry);
}