#include <gl2d.h>
#include <vector>
#include "Font.h"
#include "fontHandler.h"

// GRIT auto-genrated arrays of images
#include "font_si.h"
#include "font_16x16.h"

// Texture UV coords
#include "uvcoord_font_si.h"
#include "uvcoord_font_16x16.h"

using namespace std;

Font smallFont;
Font largeFont;

glImage smallFontImages[FONT_SI_NUM_IMAGES];
glImage largeFontImages[FONT_16X16_NUM_IMAGES];

vector<TextEntry> topText, bottomText;

void fontInit()
{
	// Set  Bank A to texture (128 kb)
	vramSetBankA(VRAM_A_TEXTURE);
	smallFont.load(smallFontImages, // pointer to glImage array
				FONT_SI_NUM_IMAGES, // Texture packer auto-generated #define
				font_si_texcoords, // Texture packer auto-generated array
				GL_RGB256, // texture type for glTexImage2D() in videoGL.h
				TEXTURE_SIZE_64, // sizeX for glTexImage2D() in videoGL.h
				TEXTURE_SIZE_128, // sizeY for glTexImage2D() in videoGL.h
				GL_TEXTURE_WRAP_S | GL_TEXTURE_WRAP_T | TEXGEN_OFF | GL_TEXTURE_COLOR0_TRANSPARENT, // param for glTexImage2D() in videoGL.h
				256, // Length of the palette (256 colors)
				(u16*) font_siPal, // Palette Data
				(u8*) font_siBitmap // image data generated by GRIT
				);

	// Do the same with our bigger texture
	largeFont.load(largeFontImages,
				FONT_16X16_NUM_IMAGES,
				font_16x16_texcoords,
				GL_RGB256,
				TEXTURE_SIZE_64,
				TEXTURE_SIZE_512,
				GL_TEXTURE_WRAP_S | GL_TEXTURE_WRAP_T | TEXGEN_OFF | GL_TEXTURE_COLOR0_TRANSPARENT,
				256,
				(u16*) font_siPal,
				(u8*) font_16x16Bitmap
				);
}

static vector<TextEntry> &getTextQueue(bool top)
{
	return top ? topText : bottomText;
}

static Font &getFont(bool large)
{
	return large ? largeFont : smallFont;
}

void updateText(bool top)
{
	for (auto &i : getTextQueue(top))
	{
		if (i.delay > 0)
		{
			glPolyFmt(POLY_ALPHA(0) | POLY_CULL_NONE | POLY_ID(1));
			--i.delay;
		}
		else if (i.delay == 0 || i.delay == TextEntry::NO_FADE)
		{
			i.x += (i.finalX * TextEntry::PRECISION - i.x) / 8;
			if (i.delay == 0)
				glPolyFmt(POLY_ALPHA((abs(i.x - i.initX * TextEntry::PRECISION)*31) / (TextEntry::PRECISION * abs(i.initX - i.finalX))) | POLY_CULL_NONE | POLY_ID(1));
		}
		getFont(i.large).print(i.x / TextEntry::PRECISION, i.y, i.message);
	}
}

void clearText(bool top)
{
	if (top)
		topText.clear();
	else
		bottomText.clear();
}

void clearText()
{
	clearText(true);
	clearText(false);
}

void printSmall(bool top, int x, int y, const char *message)
{
	getTextQueue(top).emplace_back(false, x, y, message);
}

void printLarge(bool top, int x, int y, const char *message)
{
	getTextQueue(top).emplace_back(true, x, y, message);
}

TextEntry *getPreviousTextEntry(bool top)
{
	return &getTextQueue(top).back();
}

void animateTextIn(bool top)
{
	const int SLIDE_X = 16;
	for (unsigned int i = 0; i < getTextQueue(top).size(); ++i)
	{
		TextEntry &entry = getTextQueue(top)[i];
		entry.delay = i * 3;
		entry.x = TextEntry::PRECISION * (entry.initX = entry.finalX - SLIDE_X);
	}
}