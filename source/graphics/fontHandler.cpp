#include <gl2d.h>
#include <list>
#include "Font.h"
#include "fontHandler.h"

// GRIT auto-genrated arrays of images
#include "font_si.h"
#include "font_16x16.h"

// Texture UV coords
#include "uvcoord_font_si.h"
#include "uvcoord_font_16x16.h"

using namespace std;

Font smallFont;
Font largeFont;

glImage smallFontImages[FONT_SI_NUM_IMAGES];
glImage largeFontImages[FONT_16X16_NUM_IMAGES];

list<TextEntry> topText, bottomText;

void fontInit()
{
	// Set  Bank A to texture (128 kb)
	vramSetBankA(VRAM_A_TEXTURE);
	smallFont.load(smallFontImages, // pointer to glImage array
				FONT_SI_NUM_IMAGES, // Texture packer auto-generated #define
				font_si_texcoords, // Texture packer auto-generated array
				GL_RGB256, // texture type for glTexImage2D() in videoGL.h
				TEXTURE_SIZE_64, // sizeX for glTexImage2D() in videoGL.h
				TEXTURE_SIZE_128, // sizeY for glTexImage2D() in videoGL.h
				GL_TEXTURE_WRAP_S | GL_TEXTURE_WRAP_T | TEXGEN_OFF | GL_TEXTURE_COLOR0_TRANSPARENT, // param for glTexImage2D() in videoGL.h
				256, // Length of the palette (256 colors)
				(u16*) font_siPal, // Palette Data
				(u8*) font_siBitmap // image data generated by GRIT
				);

	// Do the same with our bigger texture
	largeFont.load(largeFontImages,
				FONT_16X16_NUM_IMAGES,
				font_16x16_texcoords,
				GL_RGB256,
				TEXTURE_SIZE_64,
				TEXTURE_SIZE_512,
				GL_TEXTURE_WRAP_S | GL_TEXTURE_WRAP_T | TEXGEN_OFF | GL_TEXTURE_COLOR0_TRANSPARENT,
				256,
				(u16*) font_siPal,
				(u8*) font_16x16Bitmap
				);
}

static list<TextEntry> &getTextQueue(bool top)
{
	return top ? topText : bottomText;
}

static Font &getFont(bool large)
{
	return large ? largeFont : smallFont;
}

void updateText(bool top)
{
	for (auto &i : getTextQueue(top))
	{
		if (i.delay > 0)
		{
			glPolyFmt(POLY_ALPHA(0) | POLY_CULL_NONE | POLY_ID(1));
			--i.delay;
		}
		else //if (i.delay == TextEntry::ACTIVE)
		{
			i.x += (i.finalX * TextEntry::PRECISION - i.x) / i.invAccel;
			i.y += (i.finalY * TextEntry::PRECISION - i.y) / i.invAccel;
			glPolyFmt(POLY_ALPHA((!i.fade || i.initX - i.finalX == 0) ? 31 : (abs(i.x - i.initX * TextEntry::PRECISION)*31) / (TextEntry::PRECISION * abs(i.initX - i.finalX))) | POLY_CULL_NONE | POLY_ID(1));
			if (i.x / TextEntry::PRECISION == i.finalX)
				i.delay = TextEntry::ACTIVE; //COMPLETE;
		}
		//else
		//	glPolyFmt(POLY_ALPHA(31) | POLY_CULL_NONE | POLY_ID(1));
		getFont(i.large).print(i.x / TextEntry::PRECISION, i.y / TextEntry::PRECISION, i.message);
	}
}

void clearText(bool top)
{
	list<TextEntry> &text = getTextQueue(top);
	for (auto it = text.begin(); it != text.end(); ++it)
	{
		if ((*it).immune)
			continue;
		it = text.erase(it);
		--it;
	}
}

void clearText()
{
	clearText(true);
	clearText(false);
}

void printSmall(bool top, int x, int y, const char *message)
{
	getTextQueue(top).emplace_back(false, x, y, message);
}

void printLarge(bool top, int x, int y, const char *message)
{
	getTextQueue(top).emplace_back(true, x, y, message);
}

TextEntry *getPreviousTextEntry(bool top)
{
	return &getTextQueue(top).back();
}

void animateTextIn(bool top)
{
	const int SLIDE_X = 16;
	int numElements = 0;
	list<TextEntry> &text = getTextQueue(top);
	for (auto it = text.begin(); it != text.end(); ++it)
	{
		if ((*it).immune)
			continue;
		(*it).delay = numElements++ * 2;
		(*it).x = TextEntry::PRECISION * ((*it).initX = (*it).finalX - SLIDE_X);
	}
}